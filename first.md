# v4 Roadmap (Draft) — 범용 버그바운티 퍼징 플랫폼 리뉴얼

> 목적: “퍼징으로 찾았다”에서 끝내지 않고, **재현·검증·리포트까지 자동화**하는 버그바운티용 퍼징 플랫폼을 만든다.
> 현 상태: 프로토타입 폐기 후 **0에서 재시작**.
> 범위: gguf/onnx 같은 **바이너리 타깃 파일** 퍼징 중심.

이 문서는 구현 전에 합의해야 할 **범위/제약/실패 모드/DoD**를 고정하기 위한 설계 문서다.
불확실한 항목은 **TODO**로 남기고, 문서가 먼저 완성된 뒤에만 구현을 시작한다.

## 문서 구조 (3층)
1. **1페이지 요약**: 목표/원칙/핵심 기능/유효 버그/타깃/리포트 필드
2. **결정 로그**: 주요 결정과 근거
3. **상세 설계**: 아키텍처/파이프라인/정책/운영

---

## 1) 목표 (한 문장)
**퍼징 크래시를 “재현 가능 버그”로 승격하고, 보고서까지 자동 생성하는 버그바운티용 도구를 만든다.**

---

## 2) 핵심 원칙 (지키는 규칙)
- 기능 추가보다 **검증 가능한 결과**가 먼저다.
- 범위/제약/DoD가 없는 기능은 넣지 않는다.
- “크래시 발견”은 시작일 뿐, **재현 확인**이 없으면 보고하지 않는다.
- 타깃/입력/실행 환경은 **재현 가능한 고정 컨테이너**로 통일한다.

---

## 3) 배경/경험 (사실만)
- 과거에 **Docker Compose로 동시 8개 내외 퍼저**를 운용한 경험이 있음.
- C++ 비중이 높았음.
- gguf/onnx 파일을 다운로드해 타깃으로 퍼징하여 **CVE/버그바운티**를 목표로 함.
- 기존 프로토타입은 코드 품질이 낮아 폐기 예정.

---

## 4) 리뉴얼 핵심 변화
### 4.1 “검증”을 최우선
- 재현 **최소 3회** 성공 시만 유효 판정
- 재현 환경 고정(클린 컨테이너)
- 재현 성공 로그/스택/입력 파일 자동 저장

### 4.2 “플랫폼 정책” 내장
- **HackerOne** 정책/스코프 반영
- Out-of-scope 차단
- 리포트 템플릿 자동 생성

### 4.3 “Zero-Config”
- git clone → docker-compose up
- 퍼저 죽으면 자동 재시작

---

## 5) 최소 기능 목록 (MVP v4 기준)
### A. 실행
- 타깃별 start.sh 대신 **단일 진입점**
- Docker 컨테이너로 타깃 교체 가능

### B. 타깃 준비
- gguf/onnx 등 파일 다운로드/검증/보관 워크플로우
- 파일 해시/버전 메타데이터 자동 기록

### C. 퍼징 운영
- 퍼저 N개 동시 실행(기본 8개)
- 퍼저 자동 재시작/리소스 제한

### D. 재현/검증
- 크래시 입력 자동 재실행
- **3회 재현 성공** 시만 “유효” 분류

### E. 리포트
- 플랫폼 템플릿 출력
- 필요한 정보 자동 수집(로그, 스택, 환경, 타깃 해시)

### B. 재현/검증
- 크래시 파일 재실행 자동화
- **3회 재현 성공해야 “유효”로 분류**

### C. 리포트
- 플랫폼 템플릿 출력
- 필요한 정보 자동 수집(로그, 스택, 환경)

---

## 6) 보안/안전 우선순위 (최우선 고정)
- 입력 검증/Command Injection 방지 (모든 실행 API)
- Path Traversal 방지 (파일 업로드/seed 관리)
- XSS 방지 (리포트/대시보드)
- 타깃 경로 하드코딩 제거
- Resume 시 타깃/환경 일치 여부 강제 확인

---

## 7) 설계/구현 순서
1. **안전성 고정** (입력 검증, 경로 보안, 재현 안정화)
2. **검증 파이프라인** (재현 3회 + 중복 제거)
3. **플랫폼 정책 반영** (보고서 템플릿)
4. **자동 온보딩** (새 타깃 1시간 이내)

---

## 8) 결정해야 할 질문 (필수)
1. “유효 버그” 기준을 어디까지로 정의할 것인가?
2. 리포트 자동 생성 범위는 어디까지인가?
3. gguf/onnx 외에 우선 타깃 확장 계획은?
4. 초기 퍼징 엔진 선택: AFL++/LibFuzzer/커스텀 뮤테이터의 기준은?

---

## 9) 현재 상태 한 줄 요약
**“찾는 도구”가 아니라 “검증까지 끝내는 도구”로 리뉴얼한다.**

---

# 세부 설계 섹션 (작성 예정)

## A) 시스템 구조 (초안)
- Web Dashboard: 실행/모니터링/리포트 UI
- Fuzz Manager: Docker 기반 퍼징 실행/중지
- Engine: AFL++ + LibFuzzer (하이브리드 여부 TBD)
- Auto-Triage: ASan/GDB 로그 기반 중복 제거/요약

## B) 타깃 파일 파이프라인
- 다운로드 소스 정책 (정식 배포/공개 모델 허용 범위)
- 해시/버전/라이선스 메타데이터 저장
- 샌드박스에서 파일 파싱/로딩
- 타깃 선정 기준: huntr “Model File Formats” 목록 기반
 - 정책: **공식 배포본 우선**
 - 라이선스는 해당 배포본의 공개 사용/테스트 허용 범위 확인(정책 위반 방지)
 - 공식 배포 채널(예시)
	 - llama.cpp Releases: https://github.com/ggml-org/llama.cpp/releases
	 - onnxruntime Releases: https://github.com/microsoft/onnxruntime/releases
	 - safetensors Releases: https://github.com/huggingface/safetensors/releases
 - 버전 고정(문서 기준 최신 안정)
	 - llama.cpp: **b7921**
	 - onnxruntime: **v1.23.2**
	 - safetensors: **v0.7.0**
 - 버전 변경 시: 문서/메타 갱신 + 파일 해시 재기록

## C) 재현 파이프라인 DoD
- 동일 컨테이너에서 3회 재현 성공
- 재현 로그/스택/입력 파일 자동 저장
- 재현 실패 시 재시도/보류 정책
 - 동일 입력 판정: **입력 바이트 해시가 동일**
 - 스택 프레임 판정: **상위 3프레임 동일**
 - 스택 정규화: 주소/오프셋 제거, 모듈명+심볼 기준 비교

## D) 리포트 템플릿 DoD
- 플랫폼별 필수 필드 자동 채움
- 재현 단계 자동 생성
- 환경 정보(컨테이너 이미지/버전/커밋) 포함

## E) 운영/관찰성
- 퍼저 상태, 크래시 수, 유효 판정 수 집계
- 메트릭/로그 저장 정책

## E.1) 실행 모드
- **CLI 우선** (안정화 후 대시보드로 확장)

## E.2) 운영 지표 (초안)
- 커버리지: **시간당 신규 경로 수**
- 크래시: **시간당 신규 크래시 수**
- 유효율: **유효 크래시 / 전체 크래시**

# P) CLI 명령/플로우 (확정)
- 기본 명령: `tool run`, `tool triage`, `tool report`
- 결과 조회: `list`, `show <id>`, `export <id>`
- 기본 저장 경로: `./data`
- 기본 입력 디렉터리: `./seeds`
- 기본 타임아웃: 60초

---

# F) “유효 버그” 기준 (결정)
- 판정 기준: **SEGV/Abort 등 크래시 + 동일 입력 3회 재현 + 스택 상위 프레임 동일**
- 목표 심각도: **RCE 최우선**
- 인정 기준: **CVE 발급 또는 버그바운티 인정 가능성**이 높은 재현 가능한 버그
- DoS도 **유효로 포함** (단, 우선순위는 낮게 운영)

## G) 취약점 검증 지원 (필수 기능)
- 크래시 재현을 넘어 **PoC/재현 스크립트 자동 생성**
- LLM 기반 분석은 **증거(재현 단계/로그/코어덤프)와 함께만** 제시
- 사용자가 직접 실행해 검증할 수 있는 **재현 커맨드 제공**

# H) 하이브리드 엔진 기준 (초안)
- **LibFuzzer 모드**: in-process, 빠른 반복, 빠른 triage가 필요한 타깃
- **AFL++ 모드**: forkserver/외부 바이너리, 느린 초기 커버리지 확장 필요 타깃
- **공통 기준**
	- 입력 포맷이 복잡하고 구조적이면: custom mutator + dictionary 우선
	- 로딩 비용이 큰 타깃이면: persistent 모드/캐시 전략 우선
	- 재현/검증은 항상 동일한 컨테이너로 고정
	- 초기 기준은 위와 같고, 타깃별 성능/커버리지 지표로 조정

# I) 우선 타깃 포맷 (확정)
- GGUF
- ONNX
- safetensors

# J) 리포트 필수 필드 (확정)
- 요약
- 재현 단계
- 크래시 로그
- 스택 트레이스
- 환경 정보(컨테이너 이미지/버전/커밋)
- 입력 파일 해시

# K) 리소스/제한 정책 (초안)
- **저사양 환경 우선**: 노트북/라즈베리파이 수준에서도 동작
- 퍼저 수 기본값: 8 (환경에 따라 조정)
- CPU/RAM 상한: 보수적 기본값 제공
- 실행 시간: **무제한 설정 가능** (옵션)

# L) 실패 모드 정의 (초안)
- 재현 실패: **유효 판정 불가** (보류/재시도 큐로 이동)
- 불안정 크래시(flaky): 입력/환경 고정 후에도 재현률 낮으면 보류
- 타임아웃/행: 리소스 초과로 중지, 원인 기록
 - 재시도 횟수: **3회**
 - 플레이키 기준: **3회 중 1회 이하 재현**
 - 단일 재현 타임아웃: **60초**
 - 행 판정: **30초 무응답**
 - 재현 실패 처리: **보류 1회 재시도 → 실패 시 폐기**

# M) 저장 구조 (초안)
- 장기 보관 전제: 입력/로그/스택/환경 정보를 분리 저장
- 크래시 단위 디렉터리 구조 (타깃/해시/타임스탬프 기준)
- 재현 가능한 최소 세트(입력+환경+재현 커맨드) 우선 보관
 - 보관 기간: **30일** (보고서 제출 목표)
 - 코어덤프: **기본 OFF** (옵션으로만 활성화)
 - 압축 정책: **로그 zstd 압축**, 입력 파일은 원본 유지
 - 실패/플레이키 크래시는 보관하지 않음

# N) 정책/법적 범위
- HackerOne 정책 준수 (스코프/허용 테스트 범위 내)

# Q) 리스크/스코프 문서화 (확정)
- 스코프: **HackerOne 일반 정책 준수**
- 허용 범위 밖 테스트 금지 (대상/환경/데이터)
- 법적/정책 위반 가능성 있는 자동화는 기본 OFF

# O) 초기 하네스 구조 (TBD)
- 타깃 로더/파서 진입점 정의 필요

## O.1) 최소 하네스 공통 흐름 (초안)
1. 입력 파일 로드
2. 포맷 식별/매직 확인
3. 파서/로더 진입
4. 핵심 경로 1~2개 호출 (메타데이터 파싱, 텐서 인덱싱 등)
5. 결과 요약(성공/실패/크래시) 기록
 - 입력 정책: 다운로드는 별도 단계, 하네스는 **로컬 파일만 사용**
 - 버전 정책: **최신 안정 버전 고정** + 문서에 버전 기록
 - 구체 API/함수: **개발 1주차에 확정**

## O.2) GGUF 하네스 (초안)
- 목표: 헤더/메타데이터/텐서 인덱스 파싱 경로
- 흐름: 파일 열기 → 헤더 파싱 → KV 메타 파싱 → 텐서 디렉터리 순회
- 확인: 크래시/ASan 로그/파서 에러
 - 라이브러리(1.0): **llama.cpp 파서 사용**

## O.3) ONNX 하네스 (초안)
- 목표: protobuf 디코드 + 그래프/노드 순회
- 흐름: 파일 로드 → protobuf 파싱 → Graph/Node 순회 → 기본 검증
- 확인: 크래시/ASan 로그/파서 에러
 - 라이브러리(1.0): **onnxruntime 사용**

## O.4) safetensors 하네스 (초안)
- 목표: 헤더 JSON 파싱 + 텐서 메타 확인
- 흐름: 파일 로드 → 헤더 JSON 파싱 → 각 텐서 오프셋/크기 검증
- 확인: 크래시/ASan 로그/파서 에러
 - 라이브러리(1.0): **공식 safetensors 라이브러리 사용**

## O.5) 1.0 이후 전략
- 포맷만 고정하고, 구현 라이브러리는 추후 재선정

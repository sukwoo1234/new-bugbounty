# v2 Roadmap — 범용 버그바운티 퍼징 플랫폼 리뉴얼

> 목적: “퍼징으로 찾았다”에서 끝내지 않고, **재현·검증·리포트까지 자동화**하는 버그바운티용 퍼징 플랫폼을 만든다.
> 현 상태: 프로토타입 폐기 후 **0에서 재시작**.
> 범위: gguf/onnx 같은 **바이너리 타깃 파일** 퍼징 중심.

이 문서는 구현 전에 합의해야 할 **범위/제약/실패 모드/DoD**를 고정하기 위한 설계 문서다.
불확실한 항목은 **TODO**로 남기고, 문서가 먼저 완성된 뒤에만 구현을 시작한다.

## 문서 구조 (3층)
1. **1페이지 요약**: 목표/원칙/핵심 기능/유효 버그/타깃/리포트 필드
2. **결정 로그**: 주요 결정과 근거
3. **상세 설계**: 아키텍처/파이프라인/정책/운영

세부 수치/규칙/필드/경로 등 구현 명세는 [docs/specs.md](docs/specs.md)에 분리한다.

## 결정 목록 (TBD 닫기 순서)
- [x] 아키텍처 데이터 흐름(컴포넌트 간 통신, Job Queue, Artifact Store)
- [x] 재현 환경 고정 정책(이미지/라이브러리/환경 변수/PRNG)
- [x] 하네스/뮤테이터 전략(in-process 초기화/리셋, custom mutator 필요성)
- [x] 실패 모드 확장(Watchdog, Disk Full, False Positive)
- [x] 데이터 스키마(크래시/재현/리포트 필드)
- [x] 리포트 자동화 로직(RCA 범위, 증거/로그 결합)

---

## 1) 목표 (한 문장)
**퍼징 크래시를 “재현 가능 버그”로 승격하고, 보고서까지 자동 생성하는 버그바운티용 도구를 만든다.**

---

## 2) 핵심 원칙 (지키는 규칙)
- 기능 추가보다 **검증 가능한 결과**가 먼저다.
- 범위/제약/DoD가 없는 기능은 넣지 않는다.
- “크래시 발견”은 시작일 뿐, **재현 확인**이 없으면 보고하지 않는다.
- 타깃/입력/실행 환경은 **재현 가능한 고정 컨테이너**로 통일한다.

---

## 3) 배경/경험 (사실만)
- 과거에 **Docker Desktop 기반 컨테이너로 테스트/공격 환경**을 운용한 경험이 있음.
- C++ 비중이 높았음.
- gguf/onnx 파일을 다운로드해 타깃으로 퍼징하여 **CVE/버그바운티**를 목표로 함.
- 기존 프로토타입은 급하게 시작해 마무리가 되지 않아 중단.

---

## 4) 리뉴얼 핵심 변화
### 4.1 “검증”을 최우선
- 재현 **최소 3회** 성공 시만 유효 판정
- 재현 환경 고정(클린 컨테이너)
- 재현 성공 로그/스택/입력 파일 자동 저장

### 4.2 “플랫폼 정책” 내장
- **HackerOne** 정책/스코프 반영
- Out-of-scope 차단
- 리포트 템플릿 자동 생성

### 4.3 “Zero-Config”
- 초기 목표: 최소 설정으로 빠르게 실행 가능
- 컨테이너 기반 실행 흐름 제공 (방식 TBD)
- 퍼저 재시작 정책 자동화 (옵션/정책 TBD)

---

## 4.4 기술 스택 선정 근거 (Rust 우선)
### 선택 기준
- 장기 운영 안정성(재현/검증 파이프라인의 신뢰성)
- 성능(대용량 입력/병렬 실행)
- 배포/운영 용이성(단일 바이너리, 의존성 관리)
- 유지보수성(타입 안정성, 회귀 방지)

### 후보 언어 비교
#### Rust
- **메모리 안전** 기본값으로 크래시/취약점 위험을 줄임
- **C++급 성능**으로 병렬 실행/대용량 처리에 유리
- **단일 바이너리 배포**가 쉬워 운영 환경 표준화에 도움
- 강한 타입 시스템으로 **장기 유지보수 비용 감소**

#### Python (고려했으나 보류)
- 빠른 프로토타이핑에는 유리
- **런타임 의존성/배포 복잡도**가 증가
- 대규모 병렬 실행/대용량 처리에서 **성능 한계**
- 장기 운영 시 **환경 불일치** 이슈 발생 가능

#### C/C++ (고려했으나 보류)
- 성능은 우수하지만 **메모리 안전성 리스크**가 큼
- 유지보수 난이도가 높고 **회귀 버그**가 발생하기 쉬움
- 플랫폼/빌드 환경 차이로 **재현 안정성**이 흔들릴 수 있음

### 결론
- 플랫폼은 **Rust를 기본 언어**로 한다.
- 필요 시 타깃 라이브러리(C/C++)는 **FFI로 연동**한다.

---

## 4.5 차별점 (Why & Value)
- 단순 크래시 발견을 넘어 **깊은 버그 탐지 + 완결된 검증 자동화**를 동시에 달성한다.
- **Deep & Structured Fuzzing**: GGUF/ONNX 구조를 인식하는 custom mutator/fixup으로 얕은 파싱 에러가 아니라 **깊은 로직의 메모리 오염**을 유도한다.
- **Full-Cycle Automation**: 발견 즉시 격리 컨테이너에서 3회 재현 검증을 수행하고, 증거 번들과 리포트를 자동 생성한다.

## 4.6 RCE 탐지 방법론 (Methodology)
- 우연에 기대지 않고 **설계된 입력 변형 + 경로 타겟팅**으로 RCE 가능성을 끌어낸다.
- **Format-Aware Mutator**: 헤더/메타/오프셋/길이 필드를 의도적으로 변조해 유효 구조를 유지하면서 깊은 경로를 자극한다.
- **Targeted Harness**: 단순 로더 호출이 아닌 mmap/텐서 디코딩/메모리 할당 경로를 직접 통과하도록 하네스를 설계한다.
- **Exploitability Triage**: 크래시 발생 시 레지스터/스택/PC 오염 여부와 쓰기 가능성을 분석해 RCE 후보 등급을 부여한다.

## 4.7 CVE 확정 기준 (정책 + 기술)
- **정책 기준**: 동일 입력/환경에서 3회 재현 + top3 frame 동일 + 증거 번들(PoC/로그/스택/환경) 완비.
- **기술 기준**: 메모리 오염 증거(ASan/UBSan 로그) + exploitability triage 결과(RCE 후보/High Confidence).
- 조건 미달 시 폐기하지 않고 Manual Review로 이동한다.

---

## 5) 최소 기능 목록 (MVP v2 기준)
### A. 타깃 준비
- 공식 배포본 다운로드/검증/보관 워크플로우
- 파일 해시/버전 메타데이터 자동 기록

### B. 퍼징 실행(찾기)
- 기본 엔진: **LibFuzzer 우선**, 필요 시 **AFL++ 보조**
- 입력 전략: seed + dictionary 기반, custom mutator는 2차
- 하네스 범위: 파서/로더 + 메타데이터 순회까지 고정

### C. 크래시 수집/분류
- ASan/UBSan 로그 + 종료코드 + 스택 상위 3프레임 기준으로 1차 분류
- 동일 입력 해시 기준으로 중복 제거

### D. 재현/검증
- 동일 컨테이너에서 입력 재실행
- **3회 재현 성공** 시만 “유효” 분류
- 스택 상위 3프레임 동일성 확인

### E. 리포트
- 플랫폼 템플릿 출력
- 필요한 정보 자동 수집(로그, 스택, 환경, 타깃 해시)

> 우선순위는 **발견(퍼징) → 검증(재현) → 보고** 순서이며, 재현은 발견 결과를 전제로 수행한다.

---

## 6) 보안/안전 우선순위 (최우선 고정)
- 입력 검증/Command Injection 방지 (모든 실행 API)
- Path Traversal 방지 (파일 업로드/seed 관리)
- XSS 방지 (리포트/대시보드)
- 타깃 경로 하드코딩 제거
- Resume 시 타깃/환경 일치 여부 강제 확인

---

## 7) 설계/구현 순서
1. **안전성 고정** (입력 검증, 경로 보안, 재현 안정화)
2. **검증 파이프라인** (재현 3회 + 중복 제거)
3. **플랫폼 정책 반영** (보고서 템플릿)
4. **자동 온보딩** (새 타깃 1시간 이내)

## 7.1) MVP 최소 구현 범위 (확정)
- 목적: 핵심 플로우가 동작하는지 확인한 뒤 정책을 단계적으로 활성화한다
- 1단계(필수): CLI 스캐폴딩 + 파일 큐 기본 동작 + 단일 타깃 퍼징 실행
 - run/triage/report 명령 라우팅
 - pending -> processing -> done 이동
 - 크래시 수집 + 입력 해시 기록
- 2단계(필수): 재현 3회 + top3 frame 비교 + 리포트 필수 필드만 출력
- 3단계(선택): 네트워크 차단/스레드 억제/Watchdog/oom 분기 등 운영 정책을 순차 활성화
- 개발 원칙: 기능은 먼저 단순하게 만들고, 정책은 플래그로 점진 적용한다

---

## 8) 결정해야 할 질문 (필수)
1. “유효 버그” 기준을 어디까지로 정의할 것인가?
2. 리포트 자동 생성 범위는 어디까지인가?
3. gguf/onnx 외에 우선 타깃 확장 계획은?
4. 초기 퍼징 엔진 선택: AFL++/LibFuzzer/커스텀 뮤테이터의 기준은?

---

## 9) 현재 상태 한 줄 요약
**“찾는 도구”가 아니라 “검증까지 끝내는 도구”로 리뉴얼한다.**

---

# 세부 설계 섹션 (작성 예정)

## A) 시스템 구조 (초안)
- Web Dashboard: 실행/모니터링/리포트 UI
- Fuzz Manager: Docker 기반 퍼징 실행/중지
- Engine: AFL++ + LibFuzzer (하이브리드 여부 TBD)
- Auto-Triage: ASan/GDB 로그 기반 중복 제거/요약

## A.1) 아키텍처 데이터 흐름 (확정)
- MVP는 **Shared Volume + 파일 기반 큐**로 구성한다.
- 컴포넌트 간 통신은 **파일/디렉터리 기반**으로 단순화한다.
- Job Queue는 `./data/queue`에 job 파일로 관리한다.
- Artifact Store는 `./data/artifacts`에 크래시/재현/로그를 저장한다.

## A.2) 파일 큐 무결성 (확정)
- 파일 기반 큐로 상태 전이(pending -> processing -> done)를 관리한다.
- atomic rename 기반의 중복/레이스 허용 정책을 적용한다.
- checksum, job_id, quarantine, stale recovery, sharding, history를 운영한다.
- 세부 규칙/필드/임계값은 [docs/specs.md](docs/specs.md)에 정의한다.

## A.3) 플랫폼 인터페이스 설계 (확정)
- 확장 계획을 코드 레벨에서 지원하기 위해 핵심 컴포넌트는 trait로 분리한다.
- 구현 선택은 config 기반 factory로 분리한다.
- 기본 구현은 파일 큐/컨테이너 실행/로컬 스토리지로 시작한다.
- 세부 인터페이스/기본값은 [docs/specs.md](docs/specs.md)에 정의한다.

### 확장 계획 (조건부)
- 퍼저 수 증가로 **큐 처리 지연**이 발생하면: SQLite로 메타를 분리하고 파일 스토어는 유지
- 워커가 다수/멀티 노드로 확장되면: Redis 큐 + 파일 스토어로 전환
- 서비스 분리/멀티 팀 운영이 필요하면: gRPC 서비스 + DB로 단계적 전환

## B) 타깃 파일 파이프라인
- 공식 배포본 기반으로 다운로드/검증/보관하며 해시/버전/라이선스 메타데이터를 기록한다.
- 타깃 선정은 huntr “Model File Formats” 목록을 기준으로 한다.
- 공식 채널/버전 고정/변경 규칙은 [docs/specs.md](docs/specs.md)에 정의한다.

## B.1) 퍼징 실행(찾기) 파이프라인
- 기본 엔진: LibFuzzer 우선, 필요 시 AFL++ 보조
- 실행 흐름: 입력 생성 → 타깃 실행 → 크래시 수집 → 중복 제거
- 실행 전 해시 검증, 네트워크 차단, 아티팩트 동기화, 코퍼스 재사용을 적용한다.
- 세부 실행 정책은 [docs/specs.md](docs/specs.md)에 정의한다.

## B.2) 하네스/뮤테이터 전략 (확정)
- 기본: LibFuzzer + dictionary, 형식 인식형 mutator를 병행한다.
- 헤더 보호/스레드 억제/bootstrapped seed를 적용한다.
- fixup 허용 및 LLM 보조는 퍼징 루프 외부에서만 사용한다.
- 세부 수치/목록은 [docs/specs.md](docs/specs.md)에 정의한다.

## B.3) 하네스 리셋/메모리 캡 (확정)
- 프로세스 리셋/종료 코드 정책/Crash Loop Detection/메모리 캡/ASan 옵션을 고정한다.
- 세부 값은 [docs/specs.md](docs/specs.md)에 정의한다.

## C) 재현 파이프라인 DoD
- 동일 컨테이너에서 입력을 3회 재실행한다.
- 상위 3프레임 동일성으로 재현 성공을 판정한다.
- 재현 로그/스택/입력 파일을 자동 저장한다.
- 세부 재시도/정규화 기준은 [docs/specs.md](docs/specs.md)에 정의한다.

## C.2) 스택 정규화/중복 제거 보강 (확정)
- 스택 정규화/중복 제거 정책을 둔다.
- 스킵 목록/해시 기준 등 세부 규칙은 [docs/specs.md](docs/specs.md)에 정의한다.

## C.1) 재현 환경 고정 정책 (확정)
- 기본은 Strict, 필요 시 Debug override를 허용한다.
- 세부 화이트리스트/기록 규칙은 [docs/specs.md](docs/specs.md)에 정의한다.

## D) 리포트 템플릿 DoD
- 플랫폼별 필수 필드를 자동 채움하고 재현 단계를 생성한다.
- 환경 정보(이미지/버전/커밋)를 포함한다.
- 템플릿/매핑 규칙은 [docs/specs.md](docs/specs.md)에 정의한다.

## D.1) 리포트 템플릿 구조 (확정)
- 템플릿 구조를 정의하고 세부 필드는 [docs/specs.md](docs/specs.md)에 둔다.

## D.2) 리포트 자동 생성 파이프라인 (확정)
- 입력/매핑/출력 흐름을 정의하고 세부 규칙은 [docs/specs.md](docs/specs.md)에 둔다.

## D.3) ASan vs Release 교차 검증 (확정)
- ASan/Release 교차 검증을 수행한다.
- 성공/실패 처리 기준은 [docs/specs.md](docs/specs.md)에 정의한다.



## E) 운영/관찰성
- 퍼저 상태, 크래시 수, 유효 판정 수 집계
- 메트릭/로그 저장 정책

## E.1) 실행 모드
- **CLI 우선** (안정화 후 대시보드로 확장)

## E.2) 운영 지표 (초안)
- 운영 지표(커버리지/크래시/유효율)를 정의한다.
- 세부 정의는 [docs/specs.md](docs/specs.md)에 둔다.

## E.3) 관찰성/헬스 (확정)
- 관찰성은 heartbeat/status.json/Global Error Rate를 중심으로 설계한다.
- 세부 규칙은 [docs/specs.md](docs/specs.md)에 둔다.

## E.4) 플랫폼 자체 테스트 (확정)
- `tool self-test`로 파이프라인 전체를 검증한다.
- 시나리오/규칙은 [docs/specs.md](docs/specs.md)에 둔다.

# P) CLI 명령/플로우 (확정)
- 기본 명령/결과 조회/기본 경로를 제공한다.
- 워커 역할 분리와 기본 타임아웃 등 세부 기본값은 [docs/specs.md](docs/specs.md)에 둔다.

---

# F) “유효 버그” 기준 (결정)
- 판정 기준: **SEGV/Abort 등 크래시 + 동일 입력 3회 재현 + 스택 상위 프레임 동일**
- 목표 심각도: **RCE 최우선**
- 인정 기준: **CVE 발급 또는 버그바운티 인정 가능성**이 높은 재현 가능한 버그
- DoS도 **유효로 포함** (단, 우선순위는 낮게 운영)

## G) 취약점 검증 지원 (필수 기능)
- 크래시 재현을 넘어 **PoC/재현 스크립트 템플릿 제공**
- LLM 기반 분석은 **증거(재현 단계/로그/코어덤프)와 함께만** 제시하고, 요약/원인 설명으로 범위를 제한한다
- 사용자가 직접 실행해 검증할 수 있는 **재현 커맨드 제공**

## G.1) PoC 최소화 (확정)
- triage 시작 시 LibFuzzer `-minimize_crash=1`로 최소화된 입력을 생성한다
- 최소화 입력은 보고서에 포함하고, 원본 입력은 별도 보관한다

## G.2) ACE 수동 검증 지원 (정책)
- 프로그램 정책에 따라 ACE 증명 필수 여부를 결정한다
- ACE 필수 대상은 증거 미달 시 제출을 보류하고, 내부 기록은 유지한다
- 플랫폼이 제공하는 자동화 지원 범위를 고정한다
 - 재현 고정(컨테이너/버전/환경/시드)
 - 최소 입력 및 해시 제공
 - 실행 커맨드/타임아웃/환경 메타 자동 기록
 - 크래시 패턴 요약(스택 상위 3프레임, 시그널, 반복성)
 - 로그/스택 증거 번들링(본문/첨부 분리)
- 수동으로 수행해야 하는 단계는 사람에게 위임한다
 - 익스플로잇 시나리오 설계
 - 보호기법 고려 및 제어 가능성 검증
- 제출용 최소 증거 세트를 정의한다
 - 동일 입력/환경에서의 반복 재현 로그
 - 스택 상위 3프레임 및 시그널
 - 실행 커맨드, 입력 해시, 환경 메타

## G.3) Exploitability Triage (확정)
- triage 단계에서 crashwalk로 1차 분류를 수행한다
- 심층 분석 단계에서 exploitable 등급을 기록한다
 - 1순위: GEF exploitable 명령
 - 2순위: 간이 판정(PC/SP 오염, 시그널, top3 frame)
 - gdb-exploitable은 환경 호환이 가능한 경우에만 사용한다
- 결과 등급은 재현 메타데이터에 저장한다

## G.4) Evidence Bundle (확정)
- 증거 번들은 고정된 파일 목록으로 생성한다
 - `crash_report.txt`: 로그 + 레지스터 정보 + 주변 어셈블리 요약
 - `repro.sh`: 컨테이너 내부 재현용 단일 커맨드
 - `meta.json`: 입력 해시, 환경 메타, 실행 커맨드
- 운영 성숙 후 타깃별 유연 정책으로 전환한다

# H) 하이브리드 엔진 기준 (초안)
- **LibFuzzer 모드**: in-process, 빠른 반복, 빠른 triage가 필요한 타깃
- **AFL++ 모드**: forkserver/외부 바이너리, 느린 초기 커버리지 확장 필요 타깃
- **공통 기준**
	- 입력 포맷이 복잡하고 구조적이면: custom mutator + dictionary 우선
	- 로딩 비용이 큰 타깃이면: persistent 모드/캐시 전략 우선
	- 재현/검증은 항상 동일한 컨테이너로 고정
	- 초기 기준은 위와 같고, 타깃별 성능/커버리지 지표로 조정

# I) 우선 타깃 포맷 (확정)
- GGUF
- ONNX
- safetensors

# J) 리포트 필수 필드 (확정)
- 요약
- 재현 단계
- 크래시 로그
- 스택 트레이스
- 환경 정보(컨테이너 이미지/버전/커밋)
- 입력 파일 해시

# K) 리소스/제한 정책 (초안)
- **저사양 환경 우선**: 노트북/라즈베리파이 수준에서도 동작
- 퍼저 수 기본값: 8 (환경에 따라 조정)
- CPU/RAM 상한: 보수적 기본값 제공
- 실행 시간: **무제한 설정 가능** (옵션)

## K.1) 설정/비밀 관리 (확정)
- 실행 설정은 `config.toml`로 외부화한다
 - 예: 타임아웃, 동시 실행 수, 큐 경로, 도커 이미지 태그
- 환경 변수는 config보다 우선한다(운영 환경 주입 기준)
- 비밀 값은 환경 변수로만 주입하고 설정 파일에는 저장하지 않는다
- 설정 변경은 재컴파일 없이 반영 가능해야 한다

# L) 실패 모드 정의 (초안)
- 재현 실패: **유효 판정 불가** (보류/재시도 큐로 이동)
- 불안정 크래시(flaky): 입력/환경 고정 후에도 재현률 낮으면 보류
- 타임아웃/행: 리소스 초과로 중지, 원인 기록
 - 재시도 횟수: **3회**
 - 플레이키 기준: **3회 중 1회 이하 재현**
 - 단일 재현 타임아웃: **60초**
 - 행 판정: **30초 무응답**
 - 재현 실패 처리: **보류 1회 재시도 → 실패 시 폐기**

## L.1) 실패 모드 확장 (확정)
- 범위: 옵션 B + 컨테이너 이미지 손상 포함
- Watchdog(퍼저 hang): 무응답 30초 이상이면 중지 후 재시작, 원인 로그 기록
- 컨테이너는 `--init`을 사용해 좀비 프로세스를 수거한다
- Watchdog은 `docker kill` 후 `docker rm -f`까지 수행하고 결과를 기록한다
- Watchdog는 타깃 타임아웃보다 5초 이상 여유를 둔다
- OOM(exit code 137)은 기본적으로 infra_oom으로 분류한다
 - 동일 입력/환경에서 3회 연속 재현되면 DoS 후보로 승격한다
 - 그 외는 1회 재시도 후 failed로 이동한다
- Disk Full: 보관 우선순위 적용(재현 가능한 크래시 우선), 오래된 로그부터 삭제
- False Positive: 재현 3회 실패 또는 상위 3프레임 불일치 시 제외
- 이미지 손상: 이미지 해시 불일치 시 실행 중단, 재다운로드 후 재시도

## L.2) Disk Full GC 우선순위 (확정)
- repro_count 0인 임시 크래시 로그를 우선 삭제
- 중복 크래시는 로그를 우선 삭제하고 입력은 유지
- stdout/stderr 로그는 대형 파일부터 삭제한다
- stdout/stderr 로그는 워커 레벨에서 로테이션한다(예: 10MB 단위)

# M) 데이터/저장/하네스/정책 요약
- 데이터 스키마, 저장 구조, 하네스 설계, 운영 옵션은 [docs/specs.md](docs/specs.md)에 정의한다.
- 스코프/정책은 HackerOne 일반 정책 준수를 기본으로 한다.
